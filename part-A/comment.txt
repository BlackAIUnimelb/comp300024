For calculating the number of available moves, what is the time complexity and space
complexity of your program? You should not count the time taken to read the board
configuration from input.

Let's assume n = the number of pieces one play has
1. For each piece of the same colour, we will check if it can be moved on its four direction. Therefore:
Time complexity: O(4*n) = O(n)

Let's assume n = board size, m = the number of pieces one play has, n >> m
1. We need n units to store the board
2. We need 4*m units to try four direction for each piece
3. Since n >> m, therefore:
Space complexity: O(n + 4*m) = O(n), where n is the board size
 
For calculating the sequence of moves to eliminate all enemy pieces, how have you
modelled the problem as a search problem? What search algorithm does your
program use? If applicable, what is the branching factor of your search tree? What is
the maximum search depth? Does your algorithm always return the shortest possible
sequence of moves that will eliminate all enemy pieces?

Path finding
  1. Description

  2. Algorithm Analysis

"Massacre" strategy

# Step1: Find all black pieces that can be eliminated (Means we can put this )

# Step2: Sort valid black pieces based on nearby whitePieces (The blackPiece has the most and the closest whitePieces to be put the first)

    #1.1: First Priority:  if there is a whitePiece at the pair position
    #     Second Priority: Nearby closest whitePieces
    #     Third Priority:  Might be added in the future

# Step3: Try to eliminate the target blackPiece and update the board and priorityQueue after its been eliminated

# Step4: Re-scan the board and jump to step1 until no black pieces can be eliminated anymore


we have modeled it as a search problem in the following way: 
	Firstly, we build a function that finds shortest path between two given positions on the board. Here, we have used greedy search.

	Secondly for a given black piece, we need to find two white pieces to eliminate it. In order to find two white pieces that take least steps to the black piece, we have used the function that is mentioned above.


Branching factor is 4 because for a give position, it can have 4 possible children (child nodes). 

Maximum search depth is n, where n is the number of empty positions on the board, because for a worst scenario, a piece might move every possible empty position until it gets to the destination. 


Our algorithm does not always return the shortest sequence of moves
