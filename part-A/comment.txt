For calculating the number of available moves, what is the time complexity and space
complexity of your program? You should not count the time taken to read the board
configuration from input.

Let's assume n = the number of pieces one play has
1. For each piece of the same colour, we will check if it can be moved on its four direction. Therefore:
Time complexity: O(4*n) = O(n)

Let's assume n = board size, m = the number of pieces one play has, n >> m
1. We need n units to store the board
2. We need 4*m units to try four direction for each piece
3. Since n >> m, therefore:
Space complexity: O(n + 4*m) = O(n), where n is the board size

For calculating the sequence of moves to eliminate all enemy pieces, how have you
modelled the problem as a search problem? What search algorithm does your
program use? If applicable, what is the branching factor of your search tree? What is
the maximum search depth? Does your algorithm always return the shortest possible
sequence of moves that will eliminate all enemy pieces?

Path finding
  1. Description

  2. Algorithm Analysis

"Massacre" strategy

# Step1: Find all black pieces that can be eliminated (Means we can put this )

# Step2: Sort valid black pieces based on nearby whiteDots (The blackdot has the most and the closest whiteDots to be put the first)

    #1.1: First Priority:  if there is a whiteDot at the pair position
    #     Second Priority: Nearby closest whiteDots
    #     Third Priority:  Might be added in the future

# Step3: Try to eliminate the target blackDot and update the board and priorityQueue after its been eliminated

# Step4: Re-scan the board and jump to step1 until no black pieces can be eliminated anymore
